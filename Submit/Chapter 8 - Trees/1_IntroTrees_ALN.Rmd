---
title: "Introduction to Decision Trees"
author: "Jaime Davila"
date: "4/18/2021"
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, fig.show="hide", results=FALSE)
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
library(tidyverse)
library(tidymodels)
tidymodels_prefer()
library(rpart)
library(rpart.plot)
```

# Introduction

On today's class we will be using a dataset collated from the popular animated series, Scooby Doo:

```{r echo=TRUE, results=TRUE}
(scooby.tbl <- read_csv("~/Mscs 341 S22/Class/Data/scooby.csv") %>%
  mutate(monster_real=factor(monster_real)))
table(scooby.tbl$monster_real)
```

In particular we are interested in predicting whether or not the monster in the episode is a real or fake based on the year that the episode was aired and how well liked it was on imdb. A preliminary plot shows the relationship across variables:


```{r echo=TRUE, fig.show="hide"}
scooby.tbl %>%
   ggplot(aes(imdb, year_aired))+
    geom_jitter(alpha = 0.7, width = 0.05, 
              height = 0.2, aes(color = monster_real))
```

And as usual we will set-up or training/testing dataset:

```{r echo=TRUE, results=TRUE}
set.seed(22345)
scooby.split <- initial_split(scooby.tbl)
scooby.train.tbl <- training(scooby.split)
scooby.test.tbl <- testing(scooby.split)
```

# Recursive partitioning trees

Decisions trees introduce a completely new idea for making predictions. The fundamental  idea, as the name implies, is to use a **tree** as the means of making a decisions. The tree is built on a sequence of decisions based on the predictor variables. 

The easiest way to show a decision is to do an example using our dataset. A couple of things to notice from our code are:

* We use the library `rpart` 
* We will be making use of trees with 2 only levels (notice the parameter `tree_depth` below)

```{r echo=TRUE, results=TRUE}
scooby.model <-
  decision_tree(tree_depth=2) %>%
  set_mode("classification") %>%
  set_engine("rpart")

scooby.recipe <- recipe(monster_real ~ imdb+year_aired,
                 data=scooby.train.tbl)

scooby.wflow <- workflow() %>%
    add_recipe(scooby.recipe) %>%
    add_model(scooby.model) 

scooby.fit <- fit(scooby.wflow, scooby.train.tbl)

augment(scooby.fit, scooby.test.tbl)
```

Finally notice that we can get a text output of our tree by using `scooby.fit`

```{r echo=TRUE, results=TRUE}
scooby.fit
```

A better way to visualize our decision tree is to use the library `rpart.plot`

```{r echo=TRUE, fig.show='asis'}
library(rpart.plot)
scooby.fit %>%
  extract_fit_engine() %>%
  rpart.plot()
```

1. Talk for a couple of minutes to the people in your group about how to interpret all of the elements of the previous visualization

Another way to visualize the data when you have only two predictors is to use the library `partree` as below

```{r echo=TRUE, fig.show='asis'}
library(parttree)
scooby.train.tbl %>%
  ggplot(aes(imdb, year_aired)) +
  geom_parttree(data = scooby.fit, 
                aes(fill = monster_real), alpha = 0.2) +
  geom_jitter(alpha = 0.7, width = 0.05, 
              height = 0.2, aes(color = monster_real))
```

2. Calculate the accuracy and the confusion matrix using your testing dataset

```{r}
augment(scooby.fit, scooby.test.tbl)%>%
  conf_mat(truth = monster_real, estimate = .pred_class)

augment(scooby.fit, scooby.test.tbl)%>%
  accuracy(truth = monster_real, estimate = .pred_class)%>%
  pull(.estimate)
```


3. Calculate the accuracy of your model on your testing dataset for `tree_depth` values of 3, 5, 10 and visualize your models using `rpart.plot`. How do the different models compare to each other? Make sure to define and use a function that takes `tree_depth` as parameter.

```{r}
tree.depth.calc <- function(depth){
  scooby.model <-
    decision_tree(tree_depth=depth) %>%
    set_mode("classification") %>%
    set_engine("rpart")
  
  scooby.recipe <- recipe(monster_real ~ imdb+year_aired,
                   data=scooby.train.tbl)
  
  scooby.wflow <- workflow() %>%
      add_recipe(scooby.recipe) %>%
      add_model(scooby.model) 
  
  scooby.fit <- fit(scooby.wflow, scooby.train.tbl)
  
  scooby.fit %>%
  extract_fit_engine() %>%
  rpart.plot(roundint = FALSE)
  

  
  augment(scooby.fit, scooby.test.tbl)%>%
    accuracy(truth = monster_real, estimate = .pred_class)
  
  scooby.train.tbl %>%
  ggplot(aes(imdb, year_aired)) +
  geom_parttree(data = scooby.fit, 
                aes(fill = monster_real), alpha = 0.2) +
  geom_jitter(alpha = 0.7, width = 0.05, 
              height = 0.2, aes(color = monster_real))
  
}

tree.depth.calc(3)
tree.depth.calc(5)
tree.depth.calc(10)


```



4. The complexity parameter (`cp` or `cost_complexity`) is a key metric that penalizes the construction of large trees. Create a function `test_cp_tree` which takes as input the complexity parameter and visualizes the model and outputs its accuracy. Test the function for values of `cp`= 0.01, 0.1, 1. What is the effect of the smaller value of `cp` on your tree model?

```{r}
test_cp_three <- function(cp){
  scooby.model <-
    decision_tree(cost_complexity = cp) %>%
    set_mode("classification") %>%
    set_engine("rpart")
  
  scooby.recipe <- recipe(monster_real ~ imdb+year_aired,
                   data=scooby.train.tbl)
  
  scooby.wflow <- workflow() %>%
      add_recipe(scooby.recipe) %>%
      add_model(scooby.model) 
  
  scooby.fit <- fit(scooby.wflow, scooby.train.tbl)
  
  scooby.fit %>%
  extract_fit_engine() %>%
  rpart.plot(roundint = FALSE)
  
  scooby.train.tbl %>%
  ggplot(aes(imdb, year_aired)) +
  geom_parttree(data = scooby.fit, 
                aes(fill = monster_real), alpha = 0.2) +
  geom_jitter(alpha = 0.7, width = 0.05, 
              height = 0.2, aes(color = monster_real))
  
  augment(scooby.fit, scooby.test.tbl)%>%
    accuracy(truth = monster_real, estimate = .pred_class)
}

test_cp_three(0.01)
test_cp_three(0.1)
test_cp_three(1)
test_cp_three(0.05)

```


# Optimizing our parameters

We are interested in optimizing our parameters using a cross-validation approach. As before the steps for doing so are:

* Make sure the parameters that you will be optimizing are tuneable.
* Create a cross validation dataset
* Create a grid for searching the parameters in your dataset
* Use `tune_grid` to optimize your function across the values of your grid

```{r echo=TRUE}
# Create the model with tuneable parameters
scooby.model <-
  decision_tree(tree_depth=tune(),
                cost_complexity=tune()) %>%
  set_mode("classification") %>%
  set_engine("rpart")

  scooby.recipe <- recipe(monster_real ~ imdb+year_aired,
                 data=scooby.train.tbl)

  scooby.wflow <- workflow() %>%
    add_recipe(scooby.recipe) %>%
    add_model(scooby.model) 
```


```{r echo=TRUE}
# Create the cross-validation dataset
set.seed(1234)
scooby.folds <- vfold_cv(scooby.train.tbl, v = 10)

```

```{r echo=TRUE}
#Set up the grid
scooby.grid <- 
  grid_regular(cost_complexity(), tree_depth(), levels = 4)

scooby.grid
```

```{r echo=TRUE, fig.show='asis'}
scooby.res <-
  tune_grid(
    scooby.wflow,
    resamples = scooby.folds,
    grid = scooby.grid,
    metrics = metric_set(accuracy, roc_auc, sensitivity, specificity))

```

5. Visualize `scooby.res` and discuss the results with your group members.

```{r}
autoplot(scooby.res) + theme_light()
```

It looks like a 5 node tree is about as good as 10-15 nodes. 


6. Use `select_by_one_std_err` using accuracy as your metric and sorting in descending order the penalty parameter. Check the help of ?select_by_one_std_err and page 236 of ISLR to explain how the "one-standard-error" rule works. Use this parameter to finalize your workflow and fit it. What is your accuracy using your testing dataset?

```{r}
best.parameters <- select_by_one_std_err(scooby.res, desc(cost_complexity), tree_depth, metric = "accuracy")

# ridge.final.wf <- finalize_workflow(ridge.wf, best.penalty)
# ridge.final.fit <- fit(ridge.final.wf, data = credit.train.tbl)

scooby.final.wf <- finalize_workflow(scooby.wflow, best.parameters)
scooby.final.fit <- fit(scooby.final.wf, data = scooby.train.tbl)

scooby.final.rs <- last_fit(scooby.final.wf, scooby.split)

augment(scooby.final.fit, scooby.test.tbl)%>%
  conf_mat(truth = monster_real, estimate = .pred_class)
augment(scooby.final.fit, scooby.test.tbl)%>%
  accuracy(truth = monster_real, estimate = .pred_class)

```


Finally let's visualize our model on our training dataset using `parttree`

```{r echo=TRUE, fig.show='asis'}
scooby.train.tbl %>%
  ggplot(aes(imdb, year_aired)) +
  geom_parttree(data = scooby.final.fit, aes(fill = monster_real), alpha = 0.2) +
  geom_jitter(alpha = 0.7, width = 0.05, height = 0.2, aes(color = monster_real))

scooby.final.fit %>%
  extract_fit_engine() %>%
  rpart.plot(roundint = FALSE)
```

# Acknowledgments

This worksheet draw heavily on the following blog post from Julia Silge: https://juliasilge.com/blog/scooby-doo/


